## 목차
* [프로젝트 개요](#프로젝트-개요)
* [문제 인식](#문제-인식)
* [해결 방안](#해결-방안)
* [사용 기술](#사용-기술)
* [실행 방법](#실행-방법)
* [시사점](#시사점)


## 프로젝트 개요
데이터베이스 설계 및 최적화 - Restful API의 Latency 단축, 서버 과부하 문제 해결
- 350만 row 데이터의 재설계를 통한 API Latency 85%, 서버 메모리 사용량 85% 감축
- 서비스 형태에 최적화된 데이터베이스 및 API 재설계

## 문제 인식
1. 350만 row의 기사 데이터를 사용자가 원하는 조합으로 실시간 통계 분석하여 그래프를 제공하는 웹서비스의 데이터 처리 및 Back-End 개발을 담당  
2. 데이터 통계 (평균, 순위 등) 결과를 제공하는 API의 Latency가 최대 5초였으며, API 요청 시마다 높은 RAM 사용량(70% 이상)으로 서버 과부하 문제가 발생
3. 하기와 같이 문제 접근
- 비용이 증가하는 Vertical Scaling 방식은 최대한 지양하고, 아이디어와 기술력을 통해 문제를 해결하고자 하였음
- row 수가 많은 만큼 통계 결과가 매시간마다 크게 변하지는 않는다는 점, 사용자가 선택할 수 있는 조합은 유한하다는 점에 착안
- 서버 과부하의 원인은 트래픽 과다 혹은 API 코드의 문제가 아니라, API 요청 시 메모리에 로드되는 row가 많은 데 있음에 착안
- 수백만 검색 결과를 0.5초 이내로 제시하는 구글을 벤치마킹하여, 최대 1초 이내로 Latency를 80% 단축하겠다는 목표를 설정

## 해결 방안
1. 사용자가 선택할 수 있는 모든 조합(1000가지)에 대한 통계 결과를 모두 미리 계산하여 별도 table에 삽입
2. 사용자가 가장 적게 몰리는 새벽 시간대에 하루 1번, 최신 데이터를 포함해 통계 결과를 재계산하도록 Cron Job을 설정하고 데이터 파이프라인을 구축
3. 각 API가 접근하는 row 수를 1개로 하여 RAM 부하를 줄였으며, 접근 시 사용하는 key 3개를 모두 인덱싱 처리하여 데이터 접근 속도를 향상

## 사용 기술
* Python 3.8 (Flask 2.2)
* MongoDB  
* gunicorn
	
## 실행 방법
1. `git clone git@github.com:z3zzz/database-comparison.git` 
2. 환경변수 설정 (MYSQL_URL, MONGODB_URL)
3. 데이터 삽입 (각 데이터베이스) 
4. 서버 실행 

```terminal
cd back;
yarn install;
yarn start;
```
6. 클라이언트 실행

```terminal
cd front;
yarn install;
yarn start;
```

## 차별점
1. 하나의 API 프레임워크에서 복수의 Database 서버 연결 및 실시간 토글 기능
2. 수백만 텍스트 Row에 대한 인덱싱, 캐싱 및 각 데이터베이스 별 특성 비교 
3. 3개 서버로 구현된 분산 시스템
4. 코드 재사용성과 3계층 구조, 루즈 커플링 등 Back-End 설계 방법론에 대한 이해 및 적용


## 시사점
1. 300만 row의 경우 캐싱, 인덱싱 미적용 시 MySQL(2초 이하)이 MongoDB(5초 이하) 대비 우수 / 캐싱, 인덱싱 적용 시 MySQL(1.1초 이하)과 MongoDB(1.3초 이하) 성능 유사 
2. MongoDB의 경우 자동 캐싱이 이루어지는데, 이로인해 텍스트 서치 시 응답 시간의 일관성이 매우 낮음 (최소 0.5초, 최대 5초) / MySQL의 경우 응답 시간의 일관성이 높음
3. 인덱싱 적용 시 응답시간 평균 1초 내외로 사용자 경험 측면에서 큰 문제가 되지 않음 / 추가 리소스 사용 및 서비스 복잡도를 높이는 샤딩은 수백만 데이터 수준에서는 불필요함
4. 서비스 개발 시 DB 선정 및 설계는 해당 DB의 특징(예를 들어 MongoDB의 자동 캐싱 및 RAM 관리의 필요성), 인덱싱 적용 시의 성능, 서비스의 목적 및 사용자 경험을 모두 고려하여 신중하게 결정해야 하며, 샤딩은 최후의 수단으로 그 이전에 파티셔닝, 캐싱, 인덱싱을 우선 시도해야 함
5. 분산 시스템에서 DB 전환 시 Back-End 서버에의 영향은 DB pool에 연결할 때 사용하는 패키지뿐이며, 컨트롤러와 서비스 로직은 그대로임. 따라서 3계층 구조와 루즈 커플링을 적용하는 것이 코드 재사용률을 극대화할 수 있음
6. React 18에 새로 도입된 Transition, Suspense는 특수한 경우(UI 전환 시의 메모리 부하가 큰 경우)에 의미가 있고, 이외에는 큰 용도가 없음
